# Упражнение 2

- [Упражнение 2](#упражнение-2)
  - [Задание 1. Логические схемы](#задание-1-логические-схемы)
    - [Решение](#решение)
  - [Задание 2. Микроархитектура](#задание-2-микроархитектура)
    - [Вопрос](#вопрос)
  - [Задание 3. Сравнения](#задание-3-сравнения)
    - [Решение](#решение-1)
  - [Задание 4. Триггеры](#задание-4-триггеры)
    - [Вопросы](#вопросы)
    - [Справка: D-триггер](#справка-d-триггер)
  - [Задание 5. Кодирование информации](#задание-5-кодирование-информации)
    - [Вопрос](#вопрос-1)
  - [Задача 6. Кодирование целых чисел](#задача-6-кодирование-целых-чисел)
    - [Вопрос](#вопрос-2)
  - [Задание 7. Двубитный компаратор](#задание-7-двубитный-компаратор)
    - [Решение](#решение-2)
  - [Задание 8. Однобитный сумматор](#задание-8-однобитный-сумматор)
    - [Решение](#решение-3)
  - [Задание 9. Умножение на основание системы счисления](#задание-9-умножение-на-основание-системы-счисления)
  - [Задание 10. Кодирование информации](#задание-10-кодирование-информации)
  - [Задание 11](#задание-11)
  - [Задание 12. Добавочный код](#задание-12-добавочный-код)
  - [Задание 13. Кодирование информации](#задание-13-кодирование-информации)
  - [Задание 14. Мультиплексирование](#задание-14-мультиплексирование)
  - [Задание 15. Добавочный код](#задание-15-добавочный-код)
  - [Задание 16. Добавочный код](#задание-16-добавочный-код)
  - [Задание 17. Двубитный сумматор](#задание-17-двубитный-сумматор)
  - [Задание 18. Добавочный код и операции смены знака NEG](#задание-18-добавочный-код-и-операции-смены-знака-neg)
  - [Рекомендуемая литература и ресурсы](#рекомендуемая-литература-и-ресурсы)

## Задание 1. Логические схемы

1.1 Дана следующая логическая схема:

![](https://shitpoet.cc/sshots/2021-04-07--011400--153752202.png)

Завершить данную схему так, чтобы запись числа `x` в регистр `R` производилась в тот момент, когда `c0` равно `0`, а `c1` равно `1`.

### Решение

![](https://i.ibb.co/xD1HWFV/image.png)

## Задание 2. Микроархитектура

Узнать (если ещё не знаете), для чего в процессоры встраивают кэш. Обычно данные кэши называются L1, L2, L3.

Note: L1 также часто делится на отдельный кэш для инструкций, и отдельный кэш для данных, но в эти детали можно не уходить.

---

2.1. Пусть есть большой массив данных, размером в 1 Гб.

Есть два алгоритма: `A1` и `A2`.

Оба алгоритма обрабатывают все элементы массива данных.

Первый из них, `A1` - по некоторму принципу обходит все элементы массива в условно хаотичном порядке (на самом деле у него есть какая-то внутрення логика, но выглядит это как хаотичное обращение к элеметам).

`A1` при этом обращается к одному элементу ровно 1 раз.

Второй алгроитм, `A2` обрабатыает все элементы строго слева направо. Но он делает два полных прохода по данным.

Таким образом, `A2` обращается к каждому элементу по 2 раза.

`A1` над каждым очередным прочитанным им элементом совершает некоторое действие, продолжающееся 1 миллисекудну. (В это время не входит время, потраченное на само чтение элемента из памяти.)

`A2` над каждым очердным прочитанным им элементом тоже совершает некоторое действие, продолжающееся 0.5 миллисекунд. (В это время снова не входит время, потраченное на само чтение элемента из памяти.)

### Вопрос

Будет ли разница в скорости работы данных алгоритмов? Почему?

Ответ: Разница будет.

Алгоритм `А2` эффективней, так как данные передаются кеш блоками, называемыми кэш-линиями. Кэш-линии в большинстве x86-процессоров составляет 64 байта. Следовательно *hit-rate* (отношение *cache hit* к *cache miss*) кэша у алгоритма `А2` будет гораздо выше, чем у алгоритма `А1`.

Алгоритм `А1` будет считывать блок данных в кэш, затем, с высокой вероятностью, он обратится к другому адресу в памяти, который не хранится в кэше, тогда произойдет *cache miss*. В этом случае кэш-линию нужно выгрузить в оперативную память и загрузить новые данных в кэш, что занимает много времени.

## Задание 3. Сравнения

3.1. Придумать логические формулы для всех основных 1-битных операций сравнения: `<`, `>`, `==`, `!=`, `<=`, `>=`.

Например, 1-битную операцию `==` можно выразить как `f = (!a & !b) | (a & b)`.

Устройства, реализующие данные формулы, можно назвать 1-битными компараторами.

### Решение

`<` : `f = !a & b`
`>` : `f = a & !b`
`==` : `f = (!a & !b) | (a & b)`
`!=` : `f = (!a | !b) & (a | b)`

`<=` : `f = (!a & b) | ((a & b) | (!a & !b))`
(нашел при проверке себя) `<=` : `f = !a | b`

`>=` : `f = (a & !b) | ((a & b) | (!a & !b))`
(нашел при проверке себя) `>=` : `f = a | !b`

## Задание 4. Триггеры

Дана схема из двух триггеров и одного инвертора:

![](https://shitpoet.cc/sshots/2021-03-26--184803--1653623138.png)

Схема имеет один вход `c` и один выход `f`.

Пусть известно, что состояние левого, первого триггера изначально равно `0`.

### Вопросы

4.1. Какое значение будет на выходе `f`, если `c` равно `0`? (Имеется в виду значение не в тот момент, как только `c` стало равно `0`, а после если `c == 0` уже какое-то продолжительное время.)

Ответ: `f = 0`. Так как первый D-триггер имеет 0 на входе синхронизации и выходе `Q`, тогда второй D-триггер имеет на входе `D` значение 0 и инвертированный 0 (то есть 1) на вход синхронизации, тогда на выходе `Q` второго D-триггера будет 0, чему и будет равно `f`.

---

4.2. Далее, что будет, если теперь на вход `c` подать бит `1` и держать его какое-то время?

Ответ: `f` так же останется равен 0. После первого шага, вход `D` первого D-триггера получил 1, теперь, когда на вход синхронизации пришла 1, на выходе `Q` мы получаем 1. Эта 1 передается на вход `D` второго D-триггера, но так как у второго D-триггера инвертированная 1 (то есть 0) на входе синхронизации, выход `f` остается неизменным.

---

4.3. В целом, как далее будет меняться значение `f`, при колебательном изменении входа `c`: 0, 1, 0, 1, 0, 1 ?

Ответ: Значение выхода f будет меняться на 1 и 0 каждые 2 такта.

---

4.4. Т.е. на первом шаге `c = 0`, на втором шаге `c = 1`, на третьем шаге `c` снова равно `0` и т.д. Что будет на `f` на каждом шаге?

Ответ:

    c  f
    -----
    0  0
    1  0
    0  1
    1  1
    0  0
    1  0

---

Note: Обратите внимание, что схема содержит петлю - связь, идущую не "вперёд", а назад. Это называется обратной связью (feeback loop). Такие связи могут сильно менять поведение устройства.

### Справка: D-триггер

D-триггер - это SR-триггер, но с альтернативным интерфейсом:

Команды, которые поддерживает D-триггер:

    D W    дейстие
    ------------------------------------------
    X 0    читать текущее состояние триггера
    0 1    записать ноль в триггер
    1 1    записать единицу в триггер

где `X` значит "don't care" - "неважно", т.е. подходит любое значения бита, либо `0`, либо `1`. Т.е. от значения данного входа в данной ситуации поведение устройтва никак не зависит.

## Задание 5. Кодирование информации

В качестве цели для космической программы выбирается одно из крупных тел Солнечной системы:

    Mercury
    Venus
    Earth
    Mars
    Jupiter
    Saturn
    Uranus
    Neptune
    Pluto

### Вопрос

5.1. Сколько минимально бит потребуется, чтобы закодировать (сохранить в компьютере) то, какой объект был выбран целью программы?

Ответ: У на 9 объектов, тогда нам необходимо 4 бит, что равно 16 уникальным комбинациям. Мы можем отобразить значения таким образом:

```
Mercury - 0000
Venus   - 0001
Earth   - 0010
Mars    - 0011
Jupiter - 0100
Saturn  - 0101
Uranus  - 0111
Neptune - 1000
Pluto   - 1001
```

## Задача 6. Кодирование целых чисел

Целые числа - это все положительные и отрицательные недробные числа и ноль.

![](https://shitpoet.cc/sshots/2018-10-28--113149--243209487.png)

### Вопрос

6.1. По какому принципу организована каждая кодировка `A`, `B`, `C`?

**Кодировка A** является *прямым кодом*. Этот принцип работает как обычное представление бинарного числа, однако последний бит отводится под знак. Если `0` - число положительное, если `1` - отрицательное.

Например, у нас есть число 011, что является 3 в десятичной системе счисления. Тогда мы можем изменить первый бит числа на 1, чтобы получить `-3 == 111`.

---

**Кодировка B** является кодировкой с *двоичным смещением* (*offset binary*). Числа в такой кодировке начинаются с наименьшего отрицательного числа представления в 10 системе счисления. Например:

```
# Для чисел из 2 бит.
00 = -2
01 = -1
10 = 0
11 = 1

# Для чисел из 3 бит.
000 = -4
001 = -3
010 = -2
011 = -1
100 = 0
101 = 1
110 = 2
111 = 3
```

---

**Кодировка C** является *дополнительном кодом*. Здесь так же, как и в прямом коде, используется старший бит как знаковый. Если 0 - число положительное, если 1 - отрицательное. Принцип работы похож на обратный код, однако к числу в обратном коде добавляется 1 и при

Сделано это из-за проблем при сложении двух чисел прямом и обратном коде, нам не хватает одной единицы для получения правильного ответа. Как раз эту проблему и решает дополнительный код.

---

Note: Кодировка - это соответствие символов некоторым бинарным кодам (последовательностям из нулей и единиц).

## Задание 7. Двубитный компаратор

7.1. Собрать (изобразить) схему для 2-битного сравнения чисел, проверяюущю, что `X < Y`, где `X` и `Y` - 2-битные числа. Т.е. `X` состоит из битов `x_0` и `x_1`, а число `Y` состоит из `y_0` и `y_1`, где `x_0` - младший бит `X`, а, например, `y_1` - старший бит `Y`.

В решении нужно использовать один или несколько 1-битных компараторов. Но можно использовать и другие операции.

Числа - беззнаковые. Т.е. код `11` соответствует числу `3`.

### Решение

Для начала создадим схему для 1-битного компаратора:

![](https://i.ibb.co/KXJvFTH/image.png)

---

Далее будем использовать абстракцию 1-битного компаратора для построения 2-битного компаратора. Построим схему:

![](https://i.ibb.co/z27BYmd/image.png)

## Задание 8. Однобитный сумматор

Таблица истинности сумматора для 1-битных чисел имеет вид:

    a b  c s
    ---------
    0 0  0 0
    0 1  0 1
    1 0  0 1
    1 1  1 0

Где `s` - это непосрественно значение сумма, а `c` - это флаг переноса в следующий разряд, который также можно считать признаком переполнения.

### Решение

8.1. Задача: Изобразить логическую схему для такого сумматора, используя элементы И (`&`) или ИЛИ (`|`) с любыми инверсиями по входам или выходам.

Таблице истинности соответствует полу-сумматору. Схема:
![](https://i.ibb.co/k258wNX/image.png)

---

8.2. Вопрос: Сколько входов и выходов должен иметь сумматор для 2-битных чисел? И почему?

Ответ: Сумматор (полный) состоит из 2 полу-сумматоров и одного входа разрядности `Cin`. Для того, чтобы собрать N-битный сумматор, нам нужно каскадно соединить сумматоры, подключая выход переноса `Cout` предыдущего сумматора, на вход `Cin` след. сумматора. Выходов будет N+1 (для разрядности).

Итого: у 2-битного сумматора будет 5 входов (`A0`, `B0`, `A1`, `B1`, `Cin`) и 3 выхода (`X0`, `X1`, `Cout`).

## Задание 9. Умножение на основание системы счисления

9.1. Собрать схему, увеличивающую некоторое 4-битное число `x` в 2 раза, не используя арифметические операции или АЛУ.

    0 -> 0
    1 -> 2
    2 -> 4
    3 -> 6

Можно использовать только константы `0` и `1`, а также базовые логические операции И, ИЛИ, НЕ.

![](https://i.ibb.co/tJPRypd/image.png)

---

9.2. Вопрос: Что будет, если на вход такой схемы подать число `15`?

Ответ: `15 == 1111`, на выходе будет `11110 == 30`.

## Задание 10. Кодирование информации

10.1. Почему коды символов в азбуке Морзе имеют разную длину?

![](https://shitpoet.cc/sshots/2018-10-13--204328--13883829.png)

Ответ: Длина кода символа соответствует частоте использования буквы, поэтому на гласные в среднем приходится меньшее количество точек и тире.

А разную длину имеет для того, чтобы эффективно закодировать 26 символов латинского алфавита, для этого используются комбинации переменной длины от 1 до 4, таким образом мы можем кодировать 30 символов:

```
M - мощность алфавита = 2
| ------------------------------------------- |
| 1 |    2    |      3      |        4        |
| 2 + (2 * 2) + (2 * 2 * 2) + (2 * 2 * 2 * 2) | = 30
| ------------------------------------------- |
```

---

10.2. И почему коды для цифр при этом имеют одинаковую длину?

Ответ: Думаю это сделано по двум причинам:

1. Чтобы символы цифр не пересекались с кодом для буквенных символов. Так как нам достаточно комбинаций из 1-4 символов азбуки морзе для кодирования латинского алфавита.
2. Для удобства запоминания.

## Задание 11

Дано два 2-битных регистра.

Разработать логическую схему, выдающую `1`, если в одном из регистров есть число `3`, и выдающую `0` в противном случае.

![](https://shitpoet.cc/sshots/2021-04-11--012726--1264218580.png)

## Задание 12. Добавочный код

Если к некоторому десятичному числу прибавить 999, а затем оставить только три последние цифры, то эквивалентом какой операции это будет? Т.е. какое математический эффект имеет такой процесс?

А если прибваить вместо 998 вместо 999?

## Задание 13. Кодирование информации

Сколько бит минимально необходимо, чтобы закодировать текущее время (часы + минуты).

Количество часов может быть от 0 до 23.

Количество минут может быть от 0 до 59.

Дата не кодируется.

## Задание 14. Мультиплексирование

Дана схема с шестью переключателями:

![](https://sshots.shitpoet.cc/2024-03-30--213053--1784622073.png)

Вопрос: Что нужно подать на управляющие входы `S` и `R`, чтобы на выходах `f` и `g` были значения со входов `B` и `C`, соответственно?

`A`, `B`, `S`, `R`, `f` и `g` - однобитные.

## Задание 15. Добавочный код

Пусть у нас есть некоторая система с автоматической нормализацией углов, заданных в градусах.

Если в такой системе получается угол, больше 360, то он автоматически приводится к диапазону от 0 до 359.

    45 -> 45
    ...
    90 -> 90
    ...
    359 -> 359
    360 -> 0
    361 -> 1
    ...
    720 -> 0
    и т.д.

Отрицательные уголы также переводятся системой в соответствующие им положительные:

    -1 -> 359
    -2 -> 358
    ...
    -15 -> 345
    ...
    -180 -> 180

Вопрос: Что произойдёт с некоторым значением угла `alpha`, если к нему прибавить 270 градусов? Какое другое действие можно было сделать с данным значением, чтобы получить такой же эффект?

## Задание 16. Добавочный код

Добавочный код - это кодирова, позволяющая кодировать как положительные, так и отрицательные, т.е. любые целые числа.

Она имеет такой, например, вид для 3-битных чисел:

    011  3
    010  2
    001  1
    000  0
    111 -1
    110 -2
    101 -3
    100 -4

Вопрос: Чему будет равен результат сложения `3 + 3` в данной кодировке? Если процессор при сложении просто отбрасывает все биты, кроме младших трёх.

## Задание 17. Двубитный сумматор

Пусть `A` - двухбитное целое без знака в стандартной кодировке.

Тогда `a_1` - старший бит, `a_0` - младший бит:

    a_1 a_0   a    десятичное значение
     0   0    00           0
     0   1    01           1
     1   0    10           2
     1   1    11           3

Пусть теперь дано два таких числа: `A` и `B`.

Тогда полная таблица истинности 2-битного сумматора выглядит так:

![](https://shitpoet.cc/sshots/2018-10-18--100920--2269613846.png)

Где `A` - двубитное число, `B` - также двубитное число.

Результат сумматора - так же 2-битное число `F` в такоей же кодировке, что и `A` и `B`.

Задача: Построить 2-битный сумматор, соответсвующий данной таблице истинности.

Замечание: Вообще, данную схему можно построить, просто на основе таблицы истинности, - используя NOT, OR, AND. Но проще (и важнее) всё же её построить, используя ранее разработанный готовый компонент - 1-битный сумматор. Т.е. используя компонент максимально выского уровня абстракции.

Числа - беззнаковые. Т.е. код `11` соответствует числу `3`.

## Задание 18. Добавочный код и операции смены знака NEG

Добавочный код (код добавления до 2, two's complement code)  - это специальным образом организованная кодирова, позволяющая кодировать целые числа.

Она имеет такой вид, например, для 3-битных чисел:

    011  3
    010  2
    001  1
    000  0
    111 -1
    110 -2
    101 -3
    100 -4

Задача: Собрать логическую схему, реализующую операцию NEG (от англ. negate - отрицание), которая меняет знак числа. (Не путать с логическим отрицанием).

Другими словами, необходимо изобразить схему операции унарного минуса `-x`.

Например, если на вход данной опрации поступает код числа, например, `3` (код `011`), то на выходе должно получится `-3` (код `101`).

Другиой пример: на входы подаются биты `010` (т.е. десятичное положительное `2`), тогда на выходах схемы должна возникнуть комбинация `110` (т.е. десятичное отрицательное `-2`).

Ограничение: В решении не нужно использовать мультиплексоры (переключатели). Достаточно использовать базовые логические операции И, ИЛИ, НЕ.

Известно, что для построения решения достаточно использовать 6 логических компонентов. Возмонжо, существуют ршения с меньшим количеством компонентов. Также можно предложить решение с большим колиечеством компонентов, но не более 20.

## Рекомендуемая литература и ресурсы

Charles Petzold. Code. The Hidden Language of Computer Hardware and Software
(Чарльз Петцольд. Код: тайный язык информатики)
