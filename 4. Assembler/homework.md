# Упражнение 5. Регистровые машины и язык Ассемблера

## Задание 1

Пусть некоторый язык ассемблера имеет следующие инструкции:

    mov - пересылка междру регистрами или регистром и памятью
    add, sub, mul, div - арифметические операции
    and, or, not - логические операции
    cmp - операция сравнения
    jmp, jg, jl, je - переходы
    halt - останов машины

Note: Данная система команд - весьма минималистична, обычно процессоры имеют больше инструкций, но она впоне достаточна для Тьюринг-полноты и для знакомства с микроархитектурой процессоров.

Пусть также машина имеет 4 регистра общего назначения: `a`, `b`, `c`, `d`.

Давайте также будем считать, что размер машинного слова равен 8 бит. Т.е. и размер всех ячеек памяти, и размер всех регистров -- по одному байту. Дополнительно примем, что размер памяти RAM -- всего 256 ячеек. Таким образом, адрес любой ячейки тажке будет занимать 8 бит.

Примеры возможных команд:

    mov a, b      // переслать (move, скопировать) значение из `b` в `a`
    mov c, 42     // загрузить число 42 в регистр `c`
    mov d, [100]  // загрузить значение ячейки с адресом `100` в регистр `d`
    mov [200], a  // сохранить значения регистра `a` в ячейку с адресом `200`
    add a, b      // сложить `a + b` и поместить результат в `a`
    sub c, d      // вычесть `c - d` и поместить результат в `c`
    cmp a, b      // сравнить значения регистров `a` и `b`
    cmp c, 10     // сравнить значение регистра `c` с числом `10`
    jmp 200       // безусловный прыжок (переход, goto) на адрес 200
    jg 110        // переход если при последнем `cmp` левый операнд был больше правого
    je 120        // переход если при последнем `cmp` левый операнд был равен правому
    jl 130        // переход если при последнем `cmp` левый операнд был меньше правого
    halt          // остановка работы машины

Note: При желании вы можете предложить немного или совсем другую систему команд, но важно, чтобы в ней ключевое место занимали регистры и их было несколько.

Задание: Разработать кодировку для данной (или вашей, альтернативной) системы команд. То есть нужно придумать, как сопоставить любой возможной команде набор нулей и единиц. (Или то же самое можно выразить с помощью обычных чисел.)

Рекомендуется при разработке кодировки не гнаться за её компактностью, а наоборот. постараться сделать её максимально удобной для разработки будущей схемы процессора.

Решение:

```
# x - биты для цифр (0 или 1)
# Числа от 0 до 255
xxxxxxxx
Например:
00000000 - 0
00000010 - 2
11111111 - 255

# y - бит для обращения к регистру или ячейке памяти 
# Обращение к адресу или кодирование ASCII символов
y xxxxxxxx
Например:
1 00000001 - обратиться к ячейке с адресом [1]
1 10101010 - обратиться к ячейке с адресом [170]
0 01100001 - обратиться к регистру a (01100001 = 97 = a ASCII)

# Для битов команд будет такая логика. Мы обнуляем все биты, кроме бита определенной команды.
# m - mov
# c - cmp
# a - add
# s - sub
# u - mul
# d - div
# & - and
# | - or
# ! - not
# j - jmp
# g - jg
# l - jl
# e - je
# h - halt
Итоговая кодировка: helgj!| &dusacmy xxxxxxxx

Например:
01000000 00000000 00000000 - остановка машины
00100000 00000000 00000000 - je
00010000 00000000 00000000 - jl
00001000 00000000 00000000 - jg
00000100 00000000 00000000 - jmp
00000010 00000000 00000000 - not
00000001 00000000 00000000 - or

00000000 10000000 00000000 - and
00000000 01000000 00000000 - div
00000000 00100000 00000000 - mul
00000000 00010000 00000000 - sub
00000000 00001000 00000000 - add
00000000 00000100 00000000 - cmp
00000000 00000010 00000000 - mov

# Пример кодировки
mov d, [100]
|           mov              |     d     |   [100]   |
| -------------------------- | --------- | --------- |
| 00000000 00000010 00000000 | 0 1100100 | 1 1100100 |
```

## Задание 2. Язык Ассемблера. Линейные программы

Пример: после выполнения следующей программы

    mov a, 1
    mov b, 2
    mov c, 3
    mov d, 4

состояние регистров будет `a == 1`, `b == 2`, `c == 3` и `d == 4`.

Вопрос: Каково будет состояние регистров `a`, `b`, `c` и `d` после выполнения следующих инструкций?

    mov a, 1
    mov b, 2
    mov c, 3
    mov d, 4
    add a, b
    add b, c
    add c, d
    mul a, a
    div b, 2
    sub c, d

Считать, что разрадность регистров равна 4 бита. Таким образом, каждый регистр может хранить только числа от 0 до 15. Или, что эквивалентно, от -8 до 7, где 0111 - 7, 1111 - -1.

## Задание 3. Язык Ассемблера. Сравнения и переходы

Пример: после выполнения следующей программы с пронумированными инструкциями:

    1: mov a, 1
    2: cmp a, 1
    3: jl 5
    4: mov b, 1
    5: mov b, 2
    6: mov b, 3

состояние регистров будет `a == 1`, `b == 3` (регистры `c` и `d` не менялись).

Вопрос: Почему `b` будет `3`, а не `2` или `1`?

Note: Инструкция `cmp` только сравнивает регистры, сами регистры при этом не меняются, результат сохраняется в специальном регистре `flags`.

Note: Инструкция `jl` совершает прыжок (переход) к другой инструкции, но только если в специальном регистре `flags` отмечено, что левый операнд был меньше правого при их сравнении с помощью инструкции `cmp`. Сам прыжок не влияет на регистр `flags`.

Вопрос 2: Каково будет состояние регистров `a`, `b`, `c` и `d` после выполнения следующих инструкций?

    1:  mov a, 0
    2:  mov b, 0
    3:  mov c, 0
    4:  mov d, 0
    5:  add a, 1
    6:  mov b, a
    7:  sub b, 2
    8:  add b, 4
    9:  cmp a, b
    10: jl 13
    11: je 14
    12: jg 15
    13: mov c, 1
    14: mov c, 2
    15: mov c, 3

Считать, что разрадность регистров равна 4 бита. Таким образом, каждый регистр может хранить только числа от 0 до 15. Или, что эквивалентно, от -8 до 7, где 0111 - 7, 1111 - -1.

## Задание 4

Что будет в регистрах `a`, `b`, `c`, `d` в результате выполнения следующей программы?

    mov a, 10
    mov b, 20
    mov c, 30
    mov d, 40
    mov c, a
    mov d, b
    mov a, d
    mov b, c

## Задание 5

Что будет в регистрах `a`, `b`, `c`, `d` в результате выполнения следующей программы?

    mov a, 10
    mov b, 20
    mov c, 30
    mov d, 40
    mov c, a
    mov a, b
    mov b, c

## Задание 6

Что будет в регистрах `a`, `b`, `c`, `d` в результате выполнения следующей программы?

        mov a, 10
        mov b, 20
        mov c, 30
        mov d, 40
        cmp a, b
        jg l1
        je l2
        jl l3
    l1:
        mov c, a
        hlt
    l2:
        mov c, b
        hlt
    l3:
        mov c, b
        hlt

Note: Здесь так называемые метки `l1`, `l2`, `l3` условно обозначают номера (адреса) инструкций, на которые они указывают. Т.е., например, `l1` нужно считать указывающей на адрес инструкции `mov c, a`. Данные метки используются здесь для удобства, чтобы не нумеровать все инстукции. В самом машинном коде никаких меток не будет, вместо них будут реальные адреса инструкций.

## Задание 7

Что будет в регистрах `a`, `b`, `c`, `d` в результате выполнения следующей программы?

        mov a, 10
        mov b, 20
        mov c, 30
        mov d, 40
        cmp a, b
        jge l1
        jl l2
    l1:
        mov c, a
        mov d, b
        jmp l3
    l2:
        mov c, b
        mov d, a
        jmp l3
    l3:
        sub c, d
        hlt

Note: Инстукция `jge` (Jump if Greater than or Equal) совершает прыжок, если левое число в последнем сравнении было больше или равно правому числу.

## Задание 8

Что будет в регистрах `a`, `b`, `c`, `d` в результате выполнения следующей программы?

Как потенциально изменится содержимое памяти RAM после выполнения данной программы?

    mov a, 10
    mov [0], a
    mov [1], a
    mov [2], a
    mov [3], a
    hlt

## Задание 9

Что будет в регистрах `a`, `b`, `c`, `d` в результате выполнения следующей программы?

Как потенциально изменится содержимое памяти RAM после выполнения данной программы?

    mov a, 10
    mov [0], a
    mov [1], a
    mov [2], a
    mov [3], a
    add [0], 1
    sub [1], 2
    mul [2], 3
    div [3], 4
    hlt

Note: `mul` (multiply) - умножение, `div` (divide) - деление.

## Задание 10

Что будет в регистрах `a`, `b`, `c`, `d` в результате выполнения следующей программы?

Как потенциально изменится содержимое памяти RAM после выполнения данной программы?

    mov [0], 0
    mov [1], 1
    mov [2], 2
    mov [3], 3
    mov a, 2
    add [a], a
    hlt

## Задание 11

Что будет в регистрах `a`, `b`, `c`, `d` в результате выполнения следующей программы?

Как потенциально изменится содержимое памяти RAM после выполнения данной программы?

        mov c, 4
    l1:
        sub c, 1
        mov [c], 10
        cmp c, 0
        jg l1
        hlt

## Задание 12

Что будет в регистрах `a`, `b`, `c`, `d` в результате выполнения следующей программы?

Как потенциально изменится содержимое памяти RAM после выполнения данной программы?

        mov a, 0
        mov b, 5
        mov c, 5
    l1:
        mov d, [b]
        mov [a], d
        add a, 1
        add b, 1
        sub c, 1
        cmp c, 0
        jg l1
        hlt

## Задание 13

Что будет в регистрах `a`, `b`, `c`, `d` в результате выполнения следующей программы?

Как потенциально изменится содержимое памяти RAM после выполнения данной программы?

        mov a, 0
        mov b, 5
        mov c, 5
        add b, c
        sub b, 1
    l1:
        mov d, [b]
        mov [a], d
        add a, 1
        sub b, 1
        sub c, 1
        cmp c, 0
        jg l1
        hlt

## Задание 14

Что будет в регистрах `a`, `b`, `c`, `d` в результате выполнения следующей программы?

Как потенциально изменится содержимое памяти RAM после выполнения данной программы?

        mov a, 10
        mov c, 0
    l1:
        cmp c, 5
        jge l2
        mul [a], 2
        add a, 1
        add c, 1
        jmp l1
    l2:
        hlt

## Рекомендуемая литература и ресурсы

Charles Petzold. Code. The Hidden Language of Computer Hardware and Software
(Чарльз Петцольд. Код: тайный язык информатики)
